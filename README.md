# Telegram Bot для поддержки

Полнофункциональный бот для обработки сообщений от мобильного приложения и пересылки их в группу поддержки Telegram с поддержкой фото, push уведомлений и истории переписок.

## Функционал

1. **Прием сообщений от мобильного приложения** - сервер принимает HTTP запросы с сообщениями и фото
2. **Отправка в группу** - сообщения автоматически пересылаются в указанную группу Telegram с форматированием
3. **Поддержка фотографий** - возможность отправлять и получать фото в переписке
4. **Push уведомления** - при ответе в группе пользователь получает push уведомление (FCM для Android и iOS)
5. **История переписок** - все сообщения сохраняются в базе данных и доступны через API
6. **Обработка ответов** - когда в группе делают reply на сообщение, ответ автоматически отправляется пользователю через push

## Установка

1. **Активируйте виртуальное окружение:**
   ```bash
   source venv/bin/activate  # для macOS/Linux
   # или
   venv\Scripts\activate  # для Windows
   ```

2. **Установите зависимости:**
   ```bash
   pip install -r requirements.txt
   ```

3. **Создайте файл `.env` на основе `.env.example`:**
   ```bash
   cp .env.example .env
   ```

4. **Настройте `.env` файл:**
   - Получите токен бота у [@BotFather](https://t.me/BotFather) в Telegram
   - Добавьте бота в группу поддержки
   - Получите ID группы (см. инструкцию ниже)
   - Настройте FCM и APNs для push уведомлений (см. раздел ниже)
   - Заполните все поля в `.env`

## Как получить ID группы

### Способ 1: Через getUpdates
1. Добавьте бота в группу
2. Отправьте любое сообщение в группу
3. Откройте в браузере:
   ```
   https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates
   ```
4. Найдите в ответе `"chat":{"id":-123456789}` - это и есть `GROUP_CHAT_ID`

### Способ 2: Через бота @userinfobot
1. Добавьте @userinfobot в группу
2. Отправьте команду `/start`
3. Бот покажет ID группы

### Способ 3: Через скрипт
```bash
python get_group_id.py
```

## Настройка Push уведомлений

### Firebase Cloud Messaging (FCM)

FCM работает для Android и iOS через единый API.

1. Создайте проект в [Firebase Console](https://console.firebase.google.com/)
2. Добавьте Android приложение в проект
3. Добавьте iOS приложение в проект
4. В Firebase Console перейдите в **Project Settings** → **Cloud Messaging**
5. Скопируйте **Server key** и вставьте в `.env` как `FCM_SERVER_KEY`

Подробная инструкция по интеграции в Flutter приложение находится в [FLUTTER_GUIDE.md](FLUTTER_GUIDE.md)

## Запуск

1. **Активируйте виртуальное окружение:**
   ```bash
   source venv/bin/activate
   ```

2. **Запустите сервер:**
   ```bash
   python server.py
   ```

Сервер запустится на `http://0.0.0.0:5000` (или на порту, указанном в `.env`)

**Важно:** При запуске одновременно запускаются:
- Flask сервер для приема запросов от мобильного приложения
- Фоновый процесс для обработки обновлений от Telegram

## API

Подробная документация API для мобильного приложения находится в файле [FLUTTER_GUIDE.md](FLUTTER_GUIDE.md)

### Основные endpoints:

- **POST** `/send_message` - Отправка сообщения (с поддержкой фото)
- **POST** `/register_device` - Регистрация токена для push уведомлений
- **GET** `/message_history/<user_id>` - Получение истории переписки
- **GET** `/health` - Проверка работоспособности

### Отправка сообщения

**Endpoint:** `POST /send_message`

Поддерживает два формата:

**1. Multipart/form-data (для загрузки фото):**
```
user_id: "123456789"
user_name: "Имя пользователя" (опционально)
message: "Текст сообщения"
photo: [файл изображения] (опционально)
```

**2. JSON (без фото или с photo_url):**
```json
{
    "user_id": "123456789",
    "user_name": "Имя пользователя",
    "message": "Текст сообщения",
    "photo_url": "https://..." (опционально)
}
```

**Ответ (успех):**
```json
{
    "success": true,
    "message_id": 12345,
    "photo_url": "/uploads/uuid_filename.jpg" (если было фото)
}
```

### Регистрация устройства для push уведомлений

**Endpoint:** `POST /register_device`

```json
{
    "user_id": "123456789",
    "fcm_token": "токен от Firebase",
    "platform": "android" или "ios",
    "device_id": "device_123" (опционально)
}
```

### Получение истории переписки

**Endpoint:** `GET /message_history/<user_id>?limit=50`

**Ответ:**
```json
{
    "success": true,
    "messages": [
        {
            "message": "Текст сообщения",
            "photo_url": "/uploads/photo.jpg" или null,
            "direction": "user" или "support",
            "created_at": "2024-01-01 12:00:00"
        }
    ]
}
```

## Как это работает

1. **Мобильное приложение отправляет сообщение:**
   - POST запрос на `/send_message` с текстом и/или фото
   - Сервер сохраняет сообщение в базу данных

2. **Сервер отправляет в Telegram группу:**
   - Форматирует сообщение с ID пользователя и текстом
   - Прикрепляет фото если есть
   - Сохраняет связь между `message_id` в группе и `user_id`

3. **Поддержка отвечает в группе:**
   - Делает reply на сообщение пользователя
   - Фоновый процесс обнаруживает reply

4. **Пользователь получает push уведомление:**
   - Сервер находит токены устройства пользователя
   - Отправляет push через FCM (Android и iOS)
   - Сохраняет ответ в историю переписки

5. **Пользователь открывает уведомление:**
   - Приложение открывает экран чата с поддержкой
   - Загружается история переписки

## Структура проекта

```
smile_ai_tg/
├── venv/                    # Виртуальное окружение
├── uploads/                   # Загруженные фото (создается автоматически)
├── support_bot.db            # База данных SQLite (создается автоматически)
├── config.py                 # Конфигурация
├── bot.py                    # Логика работы с Telegram Bot API
├── server.py                 # Flask сервер для приема запросов
├── database.py               # Работа с базой данных
├── push_notifications.py     # Отправка push уведомлений
├── get_group_id.py           # Вспомогательный скрипт для получения ID группы
├── requirements.txt          # Зависимости Python
├── .env                      # Настройки (создается вручную)
├── .env.example              # Пример файла настроек
├── README.md                 # Документация
└── FLUTTER_GUIDE.md          # API документация для мобильного приложения
```

## Настройки

Все настройки хранятся в файле `.env`:

### Обязательные:
- `BOT_TOKEN` - токен бота от @BotFather
- `GROUP_CHAT_ID` - ID группы поддержки

### Опциональные:
- `SERVER_PORT` - порт для сервера (по умолчанию 5000)
- `SERVER_HOST` - хост для сервера (по умолчанию 0.0.0.0)
- `API_SECRET_KEY` - секретный ключ (для будущего использования)

### Push уведомления:
- `FCM_SERVER_KEY` - Server key из Firebase Console (для Android и iOS)

### Файлы:
- `UPLOAD_FOLDER` - директория для загрузки файлов (по умолчанию `uploads`)

## База данных

Используется SQLite база данных `support_bot.db` с тремя таблицами:

1. **messages** - история всех сообщений
2. **device_tokens** - токены устройств для push уведомлений
3. **message_mapping** - связь между сообщениями в Telegram и пользователями

База создается автоматически при первом запуске.

## Безопасность

- Не коммитьте файл `.env` в git (он уже в `.gitignore`)
- Для продакшена рекомендуется:
  - Добавить аутентификацию для API
  - Использовать HTTPS для защиты данных в транзите
  - Добавить rate limiting
  - Использовать PostgreSQL вместо SQLite для больших нагрузок
  - Настроить резервное копирование базы данных

## Troubleshooting

**Бот не отправляет сообщения в группу:**
- Проверьте, что бот добавлен в группу
- Проверьте правильность `GROUP_CHAT_ID` (должен быть отрицательным числом для групп)
- Убедитесь, что токен бота правильный

**Push уведомления не приходят:**
- Проверьте, что токен устройства зарегистрирован (`POST /register_device`)
- Убедитесь, что FCM_SERVER_KEY правильный
- Проверьте логи сервера на наличие ошибок

**Фото не загружаются:**
- Проверьте, что директория `uploads` существует и доступна для записи
- Убедитесь, что размер файла не превышает 10MB
- Проверьте формат файла (поддерживаются: png, jpg, jpeg, gif, webp)

**Сервер не запускается:**
- Проверьте, что виртуальное окружение активировано
- Убедитесь, что все зависимости установлены
- Проверьте, что порт не занят другим процессом

